(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{371:function(t,e,a){"use strict";a.r(e);var n=a(42),v=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),a("p",[t._v("Annontation是Java5开始引入的新特征，中文名称叫注解。它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用。Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。")]),t._v(" "),a("p",[t._v("Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中。")]),t._v(" "),a("h2",{attrs:{id:"注解的用处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注解的用处"}},[t._v("#")]),t._v(" 注解的用处")]),t._v(" "),a("ol",[a("li",[t._v("生成文档。这是最常见的，也是java 最早提供的注解。常用的有@param @return 等")]),t._v(" "),a("li",[t._v("跟踪代码依赖性，实现替代配置文件功能。")]),t._v(" "),a("li",[t._v("在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。")])]),t._v(" "),a("h2",{attrs:{id:"原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),a("p",[t._v("注解本质是一个继承了Annotation 的特殊接口，其具体实现类是Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的invoke 方法。该方法会从memberValues 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池。")]),t._v(" "),a("h2",{attrs:{id:"使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),a("p",[t._v("java.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：\n@Documented – 注解是否将包含在JavaDoc中\n@Retention – 什么时候使用该注解\n@Target – 注解用于什么地方\n@Inherited – 是否允许子类继承该注解")]),t._v(" "),a("h3",{attrs:{id:"retention"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#retention"}},[t._v("#")]),t._v(" @Retention")]),t._v(" "),a("p",[t._v("定义该注解的生命周期")]),t._v(" "),a("ul",[a("li",[t._v("RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。")]),t._v(" "),a("li",[t._v("RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式")]),t._v(" "),a("li",[t._v("RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。")])]),t._v(" "),a("h3",{attrs:{id:"target"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#target"}},[t._v("#")]),t._v(" Target")]),t._v(" "),a("p",[t._v("表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType 参数包括")]),t._v(" "),a("ul",[a("li",[t._v("ElementType.CONSTRUCTOR: 用于描述构造器")]),t._v(" "),a("li",[t._v("ElementType.FIELD: 成员变量、对象、属性（包括enum实例）")]),t._v(" "),a("li",[t._v("ElementType.LOCAL_VARIABLE: 用于描述局部变量")]),t._v(" "),a("li",[t._v("ElementType.METHOD: 用于描述方法")]),t._v(" "),a("li",[t._v("ElementType.PACKAGE: 用于描述包")]),t._v(" "),a("li",[t._v("ElementType.PARAMETER: 用于描述参数")]),t._v(" "),a("li",[t._v("ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明")])]),t._v(" "),a("h3",{attrs:{id:"documented"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#documented"}},[t._v("#")]),t._v(" @Documented")]),t._v(" "),a("p",[t._v("一个简单的Annotations 标记注解，表示是否将注解信息添加在java 文档中。")]),t._v(" "),a("h3",{attrs:{id:"inherited"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#inherited"}},[t._v("#")]),t._v(" @Inherited")]),t._v(" "),a("p",[t._v("定义该注释和子类的关系\n@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class 的子类。")])])}),[],!1,null,null,null);e.default=v.exports}}]);